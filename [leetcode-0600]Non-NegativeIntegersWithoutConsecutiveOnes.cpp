/**
 * Creation         :       2019.04.02 15:10
 * Last Reversion   :       2019.04.02 15:32
 * Author           :       Lingyong Smile {smilelingyong@163.com}
 * File Type        :       cpp
 * -----------------------------------------------------------------
给定一个正整数 n，找出小于或等于 num 的非负整数中，其二进制表示不包含连续的1 的个数。

示例 1:

输入: 5
输出: 5
解释: 
下面是带有相应二进制表示的非负整数<= 5：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。
说明: 1 <= num <= 109
 * -----------------------------------------------------------------
 * Crop right @ 2019 Lingyong Smile {smilelingyong@163.com}
 */

#include <stdio.h>
/**
 * 思路：动态规划
 *    长度为k的二进制数字符串没有连续的1的个数是一个斐波那契数列f(k)。
 * 比如:当k=5时，二进制数的范围是00000-11111，我们可以将其分为两个部分，
 * 00000-01111 和 10000-10111，因为任何大于11000的数字都是不成立的，
 * 因为有开头已经有了两个连续1。而我们发现其实00000-01111就是f(4)，
 * 而10000-10111就是f(3)，所以f(5) = f(4) + f(3)，这就是一个斐波那契数列.
 * 
 * 那么我们要做的首先就是建立一个这个数组，方便之后直接查值。我们从给定数字的
 * 最高位开始遍历，如果某一位是1，后面有k位，就加上f(k)，因为如果我们把当前位
 * 变成0，那么后面k位就可以直接从斐波那契数列中取值了。然后标记pre为1，再往下
 * 遍历，如果遇到0位，则pre标记为0。如果当前位是1，pre也是1，那么直接返回结果。
 * 最后循环退出后我们要加上数字n本身这种情况， 
 * 
 * 再比如：n = 10010110
 * 那么我们从二进制格式（无符号int共有32位）扫描最高位有效数字(即从左到右将该位和1与操作)。
 * 我们在(从右往左)的第7位找到第一个1，我们添加范围：00000000-01111111，即f(7)
 * 第二个1在第4位，添加范围 10000000-10001111，即f(4)
 * 第三个1在第2位，添加范围 10010000-10010011, 即f(2)
 * 第四个1在第1位，添加范围 10010100-10010101，即f(1)
 * 找到了连续的1，终止循环，返回结果 f(7)+f(4)+f(2)+f(1)+f(0)
 * 通过将这些范围内的相加，在加上本身n这个数即可。即总的范围在 00000000到10010101，
 * 任何更大的数字 <= n 将会存在连续的1.
 */ 
int Func(int num) {
    int dp[33] = {0}, result, pre, k;
    dp[0] = 1;      
    dp[1] = 2;
    for (int i = 2; i < 32; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    result = 0;
    pre = 0;
    k = 30;
    while (k >= 0) {
        if (num & ( 1 << k)) { // 1 << k,表示1左移30位，即31位为1，后面的30位都为0。用这个二进制与n进行与操作
            result += dp[k];
            if (pre) {
                return result;
            }
            pre = 1;
        } else {
            pre = 0;
        }
        k--;
    }
    return result + 1;
}

int main() {
    int n;
    scanf("%d", &n);
    printf("%d", Func(n));
    return 0;
}